import { 
  collection, 
  doc, 
  addDoc, 
  getDoc, 
  getDocs, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  orderBy,
  onSnapshot,
  serverTimestamp 
} from 'firebase/firestore';
import { httpsCallable } from 'firebase/functions';
import { db, functions } from '../config/firebase';
import { Project, CreateProjectData } from '../types';

const PROJECTS_COLLECTION = 'projects';

export class ProjectService {
  // Create a new project
  static async createProject(projectData: CreateProjectData): Promise<string> {
    try {
      const docRef = await addDoc(collection(db, PROJECTS_COLLECTION), {
        ...projectData,
        createdAt: serverTimestamp(),
        shareableLink: '', // Will be generated by Cloud Function
        collaborators: []
      });

      // Generate shareable link using Cloud Function
      const generateShareableLink = httpsCallable(functions, 'generateShareableLink');
      await generateShareableLink({ projectId: docRef.id });

      return docRef.id;
    } catch (error) {
      console.error('Error creating project:', error);
      throw error;
    }
  }

  // Get a project by ID
  static async getProject(projectId: string): Promise<Project | null> {
    try {
      const docRef = doc(db, PROJECTS_COLLECTION, projectId);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        return { id: docSnap.id, ...docSnap.data() } as Project;
      }
      return null;
    } catch (error) {
      console.error('Error getting project:', error);
      throw error;
    }
  }

  // Get projects by owner ID
  static async getProjectsByOwner(ownerId: string): Promise<Project[]> {
    try {
      const q = query(
        collection(db, PROJECTS_COLLECTION),
        where('ownerId', '==', ownerId),
        orderBy('createdAt', 'desc')
      );
      
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as Project);
    } catch (error) {
      console.error('Error getting projects by owner:', error);
      throw error;
    }
  }

  // Get projects where user is a collaborator
  static async getCollaboratedProjects(userId: string): Promise<Project[]> {
    try {
      const q = query(
        collection(db, PROJECTS_COLLECTION),
        where('collaborators', 'array-contains', userId),
        orderBy('createdAt', 'desc')
      );
      
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as Project);
    } catch (error) {
      console.error('Error getting collaborated projects:', error);
      throw error;
    }
  }

  // Update project
  static async updateProject(projectId: string, updates: Partial<Project>): Promise<void> {
    try {
      const docRef = doc(db, PROJECTS_COLLECTION, projectId);
      await updateDoc(docRef, updates);
    } catch (error) {
      console.error('Error updating project:', error);
      throw error;
    }
  }

  // Delete project
  static async deleteProject(projectId: string): Promise<void> {
    try {
      const docRef = doc(db, PROJECTS_COLLECTION, projectId);
      await deleteDoc(docRef);
    } catch (error) {
      console.error('Error deleting project:', error);
      throw error;
    }
  }

  // Add collaborator to project
  static async addCollaborator(projectId: string, userId: string): Promise<void> {
    try {
      const docRef = doc(db, PROJECTS_COLLECTION, projectId);
      await updateDoc(docRef, {
        collaborators: [...(await this.getProject(projectId))?.collaborators || [], userId]
      });
    } catch (error) {
      console.error('Error adding collaborator:', error);
      throw error;
    }
  }

  // Remove collaborator from project
  static async removeCollaborator(projectId: string, userId: string): Promise<void> {
    try {
      const project = await this.getProject(projectId);
      if (project) {
        const updatedCollaborators = project.collaborators.filter(id => id !== userId);
        await updateDoc(doc(db, PROJECTS_COLLECTION, projectId), {
          collaborators: updatedCollaborators
        });
      }
    } catch (error) {
      console.error('Error removing collaborator:', error);
      throw error;
    }
  }

  // Get project by shareable link
  static async getProjectByShareableLink(shareableLink: string): Promise<Project | null> {
    try {
      const q = query(
        collection(db, PROJECTS_COLLECTION),
        where('shareableLink', '==', shareableLink)
      );
      
      const querySnapshot = await getDocs(q);
      if (!querySnapshot.empty) {
        const doc = querySnapshot.docs[0];
        return { id: doc.id, ...doc.data() } as Project;
      }
      return null;
    } catch (error) {
      console.error('Error getting project by shareable link:', error);
      throw error;
    }
  }

  // Real-time listener for project changes
  static subscribeToProject(projectId: string, callback: (project: Project | null) => void) {
    const docRef = doc(db, PROJECTS_COLLECTION, projectId);
    return onSnapshot(docRef, (doc) => {
      if (doc.exists()) {
        callback({ id: doc.id, ...doc.data() } as Project);
      } else {
        callback(null);
      }
    });
  }

  // Real-time listener for user's projects
  static subscribeToUserProjects(ownerId: string, callback: (projects: Project[]) => void) {
    const q = query(
      collection(db, PROJECTS_COLLECTION),
      where('ownerId', '==', ownerId),
      orderBy('createdAt', 'desc')
    );
    
    return onSnapshot(q, (querySnapshot) => {
      const projects = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }) as Project);
      callback(projects);
    });
  }
}
